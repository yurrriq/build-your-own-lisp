% -*- mode: ess-noweb; ess-noweb-default-code-mode: c-mode; -*-


\documentclass[nobib]{tufte-handout}


\input{preamble.tex}


\title{Build Your Own Lisp}


\hypersetup{
  pdffitwindow=true,
  pdfstartview={FitH},
  pdftitle={Build Your Own Lisp},
  pdfauthor={Eric Bailey <eric@ericb.me>},
  pdfsubject={Working through the eponymous book},
  pdfkeywords={UNIX, C language, learning, lisp, programming langauge theory},
  colorlinks=true,
  linkcolor=ErlangRed,
  urlcolor=ErlangRed
}


\date{%
  May 10, 2018
  \thanks{Last updated \today}%
}


\begin{document}

\maketitle
@


\begin{abstract}
<<parsing.c>>=
<<Include the necessary headers.>>


<<Load the Lispy grammar.>>


int main(int argc, char *argv[])
{
    <<Define the language.>>


    <<Print version and exit information.>>


    <<Loop until the input is empty.>>


    <<Undefine and delete the parsers.>>


    return 0;
}
@
\end{abstract}


\tableofcontents


\newpage
\section{Welcome}

What good is a REPL\todoo{acronym} without a welcome message?
For now, simply print the version and describe how to exit.

<<Print version and exit information.>>=
puts("Lispy v0.0.1");
puts("Press ctrl-c to exit\n");
@


\section{Defining the Language}

In order to make sense of user input, we need to define a grammar.

<<lispy.mpc>>=
integer  : /-?[0-9]+/ ;
decimal  : /-?[0-9]+\.[0-9]+/ ;
number   : <decimal> | <integer> ;
operator : '+' | '-' | '*' | '/' ;
expr     : <number> | '(' <operator> <expr>+ ')' ;
lispy    : /^/ <expr>+ /$/ ;
@

\todoo{Describe this trick}
<<Load the Lispy grammar.>>=
static const char LISPY_GRAMMAR[] = {
#include "lispy.xxd"
};
@ %def LISPY_GRAMMAR
\marginnote{See: \url{https://stackoverflow.com/a/411000}}


To implement the grammar, we need to create some parsers.

<<Define the language.>>=
mpc_parser_t *Integer  = mpc_new("integer");
mpc_parser_t *Decimal  = mpc_new("decimal");
mpc_parser_t *Number   = mpc_new("number");
mpc_parser_t *Operator = mpc_new("operator");
mpc_parser_t *Expr     = mpc_new("expr");
mpc_parser_t *Lispy    = mpc_new("lispy");

@ %def Integer
@ %def Decimal
@ %def Number
@ %def Operator
@ %def Expr
@ %def Lispy


Finally, using the defined grammar and each of the [[<<created parsers>>]],%
%
<<created parsers>>=
Integer, Decimal, Number, Operator, Expr, Lispy
@
%
we can define the Lispy language.

<<Define the language.>>=
mpca_lang(MPCA_LANG_DEFAULT, LISPY_GRAMMAR,
          <<created parsers>>);
@


Since we're implementing this in C, we need to clean up after
ourselves.  The \cee{mpc} library makes this easy, by providing the
[[mpc_cleanup]] function.

<<Undefine and delete the parsers.>>=
mpc_cleanup(6, <<created parsers>>);
@


\section{R is for Read}

To implement the R in REPL\todoo{acronym},
use [[readline]] from editline\todoo{Add a link}.

<<Read a line of user input.>>=
char *input = readline("> ");
@ %def input

To check whether user input is nonempty, and thus whether we should
continue looping, use the following expression.

<<[[input]] is nonempty>>=
input && *input
@

Here, \cee{input} is functionally equivalent to \cee{input != NULL}, and
\cee{*input} is functionally equivalent to \cee{input[0] != '\0'}, i.e.
[[input]] is non-null and nonempty, respectively.

So long as [[input]] is nonempty, add it to the \cee{editline} history table.
<<Add [[input]] to the history table.>>=
add_history(input);
@

Declare a variable, [[res]], to hold the results
of attempting to parse user input as Lispy code.

<<Declare a variable to hold parsing results.>>=
mpc_result_t res;
@

To attempt said parsing, use [[mpc_parse]], the result of which
we can branch on to handle success and failure.

<<The input can be parsed as Lispy code.>>=
mpc_parse("<stdin>", input, Lispy, &res)
@


\section{E is for Eval(uate)}

\todor{Evalute the AST}

<<Eval(uate) user input and print the result.>>=
<<Declare a variable to hold parsing results.>>
if (<<The input can be parsed as Lispy code.>>) {
    <<Print and delete the AST.>>
} else {
    <<Print and delete the error.>>
}
@ %def res


\section{P is for Print}

For now, simply print the AST\todoo{acronym} upon success,
<<Print and delete the AST.>>=
mpc_ast_print(res.output);
mpc_ast_delete(res.output);
@

or the error upon failure.
<<Print and delete the error.>>=
mpc_err_print(res.error);
mpc_err_delete(res.error);
@

\section{L is for Loop}

<<Loop until the input is empty.>>=
bool nonempty;
do {
  <<Read, eval(uate), and print.>>
} while (nonempty);
@ %def nonempty

As previously described, in the body of the loop, {R}ead a line of user input.

<<Read, eval(uate), and print.>>=
<<Read a line of user input.>>
@

If, and only if, it's not empty, add it to the history table,
evaluate it, and print the result.

<<Read, eval(uate), and print.>>=
if ((nonempty = (<<[[input]] is nonempty>>))) {
    <<Add [[input]] to the history table.>>
    <<Eval(uate) user input and print the result.>>
}

@

Dealloc the space pointed to by [[input]],
making it available for futher allocation.

<<Read, eval(uate), and print.>>=
free(input);
@
\marginnote{N.B. This is a no-op when \cee{!input}.}


\section{Headers}

<<Include the necessary headers.>>=
<<Include the boolean type and values.>>
<<Include the standard I/O functions.>>
<<Include the standard library definitions.>>

<<Include the line editing functions from libedit.>>
<<Include the micro parser combinator definitions.>>
@


<<Include the boolean type and values.>>=
#include <stdbool.h>
@ %def bool

<<Include the standard I/O functions.>>=
#include <stdio.h>
@ %def printf

<<Include the standard library definitions.>>=
#include <stdlib.h>
@ %def free

<<Include the line editing functions from libedit.>>=
#include <editline/readline.h>
@ %def add_history
@ %def readline

<<Include the micro parser combinator definitions.>>=
#include <mpc.h>
@ %def mpc_ast_delete
@ %def mpc_ast_print
@ %def mpc_cleanup
@ %def mpc_err_delete
@ %def mpc_err_print
@ %def mpc_parse
@ %def mpc_parser_t
@ %def mpc_result_t


\newpage
\section{Full Listing}

\inputc{parsing.c}


\newpage
\section{Chunks}
\nowebchunks


\newpage
\section{Index}
\nowebindex


\todor{Add a bibliography}


\todor{Add a glossary}


\newpage
\listoftodos

\end{document}
